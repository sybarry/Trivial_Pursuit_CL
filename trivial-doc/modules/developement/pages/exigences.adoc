:project: Trivial Pursuit
= Spécification des exigences

== Introduction 

Ce chapitre décrit les exigences du projet «{project}». Il suit la norme ISO/IEC/IEEE https://ieeexplore.ieee.org/document/8559686[29148-2018].


=== Avant-propos

L'objectif de ce document est de décrire les spécifications des exigences du projet "{project}" pour les étudiants en génie logiciel.

Le public visé par cette spécification comprend les développeurs potentiels de l'application, ainsi que les personnes chargées de l'évaluation technique.

=== Définitions, acronymes et abréviations

Norme ISO/IEC/IEEE 29148-2018:: Ingénierie des systèmes et du logiciel -- Processus du cycle de vie -- Ingénierie des exigences

SRS:: _Software Requirements Specification_, Spécification des Exigences Logicielles

// NOTE: Décrivez toutes les normes ou conventions typographiques qui ont été suivies lors de la rédaction de ce SRS, telles que les polices de caractères ou les mises en évidence qui ont une signification particulière. Par exemple, indiquez si les priorités des exigences de niveau supérieur sont supposées être héritées par les exigences détaillées, ou si chaque énoncé d'exigence doit avoir sa propre priorité.

.Acronymes
[%header]
|===
| Acronyme | Description

| JDBC
| Java DataBase Connectivity

| JPA
| Java Persistence API

| SGBD
| Système de Gestion de Bases de Données

|===

.Définitions
[%header]
|===

| Terme | Définition

| WebSockets
| Protocole servant à établir des connexions TCP persistantes entre _serveurs_ et _clients_

|===

=== Public visé et suggestions de lecture

Ce document est à la destination des étudiants de première année du Master Informatique de Nantes Université.

=== Portée du projet

// NOTE: Fournissez une brève description du logiciel spécifié et de son objectif, y compris les avantages, les objectifs et les buts pertinents. Reliez le logiciel aux objectifs de l'entreprise ou aux stratégies commerciales. Si vous disposez d'un document distinct sur la vision et la portée, faites-y référence plutôt que d'en reproduire le contenu ici.

Le système logiciel à produire est une version simplifiée du jeu de plateau {project}, qui sera désigné par le terme "{project}" dans le présent document.

Le système {project} permettra à des joueurs de différents endroits de s'affronter dans des parties courtes et intensives.

=== Références

. «IEEE Standard 830-1993: IEEE Recommended Practice for Software Requirements Specifications»

. «Trivial Pursuit -- Genus Edition». Horn Abbot International Limited

. Trivial Pursuit. Article https://fr.wikipedia.org/wiki/Trivial_Pursuit[Wikipedia]

. Les règles du jeu{nbsp}: Trivial Pursuit. https://www.ribambel.com/article/les-regles-du-jeu-trivial-pursuit/5640[Ribambel]

=== Vue d’ensemble 

Le reste de ce document contient une description globale du système logiciel {project} (section <<description>>, les exigences fonctionnelles spécifiques (section <<functional>>) et les exigences non-fonctionnelles du système (voir <<nonfunctional>>.

== Organisation du chapitre

[#description]
== Description générale

=== Perspectives du produit

{project} est un jeu de plateau où plusieurs joueurs s'affrontent.
Le logiciel {project} doit permettre aux joueurs qui sont connectés à Internet d'utiliser leurs appareils connectés pour jouer.
Ainsi, "{project}" est une version électronique en ligne du jeu de plateau.

Bien que le système soit distribué et organisé en différents composants, les joueurs doivent le percevoir comme un seul logiciel.
La <<deployment>> présente l'architecture globale préconisée du logiciel.
Il est organisé en trois nœuds logiques distincts.
Le nœud `Navigateur` contient les artefacts nécessaires à l'exécution du `Client Web`.
Ce client utilise des _WebSockets_ pour communiquer avec l'artefact `Serveur TP`, déployé sur le nœud `Serveur`.

Le nœud `Serveur` contient tous les artefacts nécessaires à la gestion de plusieurs parties du jeu.
Le `Serveur TP` utilise JDBC pour interroger le `SGBD`, qui stocke toutes les données du logiciel.
Le `SGBD` déployé sur le nœud `Database`.

Les joueurs interagissent avec le `Client Web`, qui utilise le protocole les WebSockets pour communiquer avec (au maximum) un serveur de jeu.

[#deployment]
.UML Diagramme de déploiement 
[plantuml]
----
include::example$deployment-diagram.puml[]
----

IMPORTANT: Un *Nœud Logique* est une cible de déploiement qui représente une ressource informatique sur laquelle
les artefacts peuvent être déployés pour être exécutés. +
Plusieurs nœuds logiques peuvent s'exécuter sur un même *Nœud Physique* ou *Dispositif*.

{project} sera le premier d'une ligne de produits de type "Jeu de plateau".
Son architecture servira comme exemple à d'autres produits.

=== Fonctionnalités du produit

Le logiciel {project} doit assurer trois fonctions principales :

. Connexion au serveur{nbsp}: permettre à un joueur de rejoindre un serveur pour ensuite choisir une partie.
. Création de jeu : permettre aux joueurs de se découvrir et de commencer une partie.
. Le jeu{nbsp}: permettre aux joueurs de jouer effectivement à {project} jusqu'à la victoire de l'un d'entre eux.

=== Caractéristiques et classes d'utilisateurs

Le logiciel {project} a deux classes d'utilisateurs{nbsp}: les joueurs et les administrateurs.

Les joueurs peuvent avoir différents niveaux{nbsp}: débutants, intermédiaires ou experts. +
Cependant, indépendamment de leur niveau, les joueurs utilisent la même interface utilisateur pour jouer les uns contre les autres.

Les administrateurs peuvent gérer les joueurs et les parties.


=== Environnement opérationnel

Le Serveur doit fonctionner sur tout système d'exploitation populaire et récent{nbsp}: Linux, Windows, ou MacOS.
Le client Web devrait fonctionner sur tout navigateur Web compatible avec les WebSockets{nbsp}: Firefox (≥ 7.0), Chrome (≥ 5.0), Safari (≥ 5.0), ou Edge (≥ 12.0).

== Contraintes de conception et de mise en œuvre

=== Langages de programmation

. Le serveur de jeu doit être développé en Java (version ≥ 11), en utilisant le https://spring.io[Spring Boot] (version ≥{nbsp}3.0.0).
. Le client doit être développé en TypeScript (version ≥ 4.0), en utilisant le https://angular.io[Angular Framework] (version ≥ 16.0).


=== Langage de conception

. Les documents sur le développement du logiciel doivent être écrits dans le format Asciidoc.
. Les diagrammes UML d'analyse, conception et mise en œuvre devront être réalisés en PlantUML.

=== Conception
=== Mise en œuvre

. Les tests dynamiques doivent utiliser JUnit Jupiter (version ≥ 5.0) et Jasmine (version ≥ 5.1.0).
. Le code doit journaliser ses principales opérations en utilisant https://www.slf4j.org[SLF4J] et
https://www.npmjs.com/package/typescript-logging[TypeScript Logging].

=== Outils de production

. Tous les artefacts logiciels doivent utiliser un outil de production{nbsp}: Maven (version ≥ 3.9.0) ou
Gradle (version ≥ 8.0) pour Java et npm (version ≥ 9.0.0) pour TypeScript.

=== Outils de développement

=== Bibliothèques et composants logiciels

== Vérification

. Les méthodes du projet doivent être vérifiées grâce aux tests unitaires, indépendamment du langage utilisé.
Chaque test unitaire doit décrire clairement son intention.
. L'interface (API) des composants ou modules doubles tests doivent être vérifiées grâce aux tests fonctionnels.
. Les tests des composants/modules doivent être indépendants des autres composants.
Des doublures de test doivent être utilisées pour assurer l'isolation des tests.

== Documentation utilisateur

Aucune documentation utilisateur n'est requise pour la première version du logiciel.

=== Hypothèses et dépendances

Aucune jusqu'à présent.

=== Exigences reportées

. Les versions futures du logiciel comprendront l’utilisation de différentes interfaces utilisateur{nbsp}:
Client Lourd, _Smartphones_, etc.

== Exigences en matière d'interface externe

* Aucune

=== Interfaces utilisateur

* Aucune exigence

=== Interfaces matérielles

* Aucune, le logiciel n'interagit pas directement avec un quelconque dispositif matériel.

=== Interfaces logicielles

La partie client du logiciel doit fonctionner sur des navigateurs web, tandis que la partie serveur doit interagir avec
une base de données par le biais de l'API Java Persistence (JPA).



=== Interfaces de communication

* Les communications entre le client et le serveur de jeu doivent utiliser des Websockets.

[#functional]
== Exigences fonctionnelles

////
[NOTE]
====
Décrire les exigences fonctionnelles du système qui peuvent être exprimées et langage naturel. Pour plusieurs applications, c’est la partie principale de la SEL et son organisation doit, par conséquent, être bien réfléchie. Elle est habituellement hiérarchisée par caractéristiques, mais elle peut l’être, par utilisateur ou par sous-système. Les exigences fonctionnelles peuvent inclure les caractéristiques, les capacités et la sécurité.

Lorsque des outils de développement, tels des référentiels d’exigences ou des outils de modélisation sont utilisés, on peut référer à ces données en indiquant l’endroit et le nom de cet outil]
====
////


=== Fonctionnalité «{nbsp}Joindre une partie{nbsp}»


==== Description et priorité

Cette fonctionnalité permet à un joueur de se connecter au serveur de jeu, pour ensuite participer à une partie.

Priorité:: Haute

==== Séquences de Stimulus/Réponse

// NOTE: Liste des séquences d'actions de l'utilisateur et des réponses du système qui stimulent le comportement défini pour cette fonctionnalité. Celles-ci correspondront aux éléments de dialogue associés aux cas d'utilisation.

==== Exigences fonctionnelles

////
[NOTE]
====
Détaillez les exigences fonctionnelles détaillées associées à cette fonctionnalité. Il s'agit des capacités logicielles qui doivent être présentes pour permettre à l'utilisateur d'effectuer les services fournis par la fonction ou d'exécuter le cas d'utilisation. 

Indiquez comment le produit doit réagir aux conditions d'erreur prévues ou aux entrées non valides. Les exigences doivent être concises, complètes, non ambiguës, vérifiables et nécessaires. 

Utilisez la mention "A faire" pour indiquer que les informations nécessaires ne sont pas encore disponibles.

Chaque exigence doit être identifiée de manière unique par un numéro de séquence ou une étiquette significative.

* REQ-1:	
* REQ-2:
====
////

==== Description sous la forme d'un cas d'utilisation

.Cas d'utilisation «{nbsp}Joindre une partie{nbsp}»
include::partial$req-joindre-partie.adoc[]

=== Fonctionnalité «{project}Rejoindre une partie{project}»

// NOTE: Ajoutez la description de la fonctionnalité "B" en vous basant sur la structure de la fonctionnalité "A"

==== Description sous la forme d'un cas d'utilisation
.Cas d'utilisation «{nbsp}Rejoindre une partie{nbsp}»
include::partial$req-joindre-partie.adoc[]

=== Fonctionnalité «{nbsp}Jouer un tour{nbsp}»


==== Description sous la forme d'un cas d'utilisation

.Cas d'utilisation «{nbsp}Jouer un tour{nbsp}»
include::partial$req-jouer-tour.adoc[]


[#nonfunctional]
== Autres exigences non-fonctionnelles

=== Exigences de performance 

. Le jeu doit être _jouable_, ce qui signifie que les utilisateurs doivent avoir un retour rapide de leurs actions et que les retards dus aux problèmes de communication/connexion doivent être correctement tenus.
. Le client Web doit pouvoir s'exécuter sur un ordinateur personnel doté de 4 Go de RAM.


=== Exigences de sécurité

* Aucune

=== Attributs de qualité logicielle

==== Extensibilité

NOTE: TODO

==== Maintenabilité

. Le logiciel doit être lisible et facile à maintenir.
. La source Java doit respecter les directives de Google{nbsp}: https://google-styleguide.googlecode.com/svn/trunk/javaguide.html.

=== Règles métier


== Autres exigences

NOTE: Définissez toute autre exigence non couverte ailleurs dans le SRS. Il peut s'agir d'exigences relatives à la base de données, à l'internationalisation, à la législation, aux objectifs de réutilisation du projet, etc. Ajoutez toute nouvelle section pertinente pour le projet.

[glossary]
=== Annexe A : Glossaire

include::termes.adoc[]

=== Annexe C : Liste à déterminer

