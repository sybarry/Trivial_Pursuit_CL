= Spécification des composants

[NOTE]
====
Objectif::
Découpage de la solution en composants (ou sous-systèmes), affectation des responsabilités aux composants et spécification des interfaces fournies et requises par ces composants

Moyens::
Utilisez des diagrammes d'interaction (séquence, communication) pour décrire l'échange de messages entre les composants pour en déduire leurs interfaces.
====

== Vue globale des composants

.Diagramme de composants décrivant la solution proposée
[plantuml]
....
include::example$dc-global.puml[]
....

.Un autre exemple

== Composant A

[plantuml]
....
@startuml
left to right direction

component A as "Component A" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required


sws --() Provided
Required  )-- cws
@enduml
....

=== Responsabilités du Composant A

* Serveur :

.Quelques exemples
* Créé tous les objets relatifs au jeu : les joueurs, les cartes, les merveilles et les initialise.
* Gère les connections au serveur et les pseudos
* Lorsque tous les joueurs sont prêts, lance la partie et distribue au client ce dont il a besoin : Merveille, cartes au tour 1
* À chaque tour, il reçoit la liste suivante : Le paquet de cartes non jouées, la carte jouée/déposée sur la merveille/défossée,
le nombre d'argent à ajouter au joueur
* Une fois que tout le monde a envoyé son jeu, envoie à chaque client : ses nouvelles cartes, les cartes jouées depuis le début de la partie de son voisin de gauche et de droite
* Gère les tours de la partie
* Définit le joueur gagnant

=== Interfaces fournies

==== Interface A

[TIP]
====
Utilisez la notation UML pour spécifier la signature de chaque operation de l'interface.

====

[WARNING]
====
* La syntaxe de la notation UML est différente de celle de Java{nbsp}!
* Les types de base sont  différents aussi{nbsp}! Par exemple, `int`, `float`, `bool` ne sont pas des types UML.
* Si les paramètres sont multivalués (par ex. ensemble, séquence, etc.) utilisez les cardinalités: `names : String [1..4]`
* `List<>`, `Set<>`, etc. ne sont pas des types UML.
====

[plantuml]
....
interface A {
    operationA(a: String, b: Integer): Boolean
}
....

TIP: Si nécessaire, utilisez le langage OCL pour spécifier les pré et post-conditions des opérations.

.Contraintes sur les operations
[source, ocl]
----
context A::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----


==== Interface B

[plantuml]
....
interface B {
    operationB(a: String, b: Integer): Boolean
}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----


== Composant B

[note]
====
Description de ses responsabilités et de ses interfaces
====

=== Interface C
[plantuml]
....
interface GameServer {
connect(pseudo: String, password: String, ip: String, port: Integer):Boolean
createGame(numberOfPlayers : Integer): Integer
join(gameId : Integer): Integer
notifyPlayersReady(): String
chooseRole(role: String, playerId: Integer)
resist(numberOfPawns: Integer)
playPlaceCard(playerId: Integer, cardName: String)
playHuntCard(cardName: String)
letGo()
putToken(tokenName: String, cardNames: String [0..2])
}
....

== Interactions

[TIP]
====
* Utilisez les diagrammes d'interaction de la notation UML pour valider les interfaces des composants.

* Basez-vous sur les cas d'utilisation (spécification des exigences) pour illustrer les interactions entre les différents composants
====

[WARNING]
====
* En UML, les interactions se passent au niveau des instances.
* Rappel:
** Niveau classes: Classes, opérations, types, etc.
** Niveau instances: Objets, appels d'opération, valeurs, etc.
====

.Connexion au serveur
[plantuml]
....
@startuml

actor "ClientA:Client" as C1
actor "ClientB:Client" as C2
actor "ClientC:Client" as C3

C1 -> Serveur: Connect("Teddy")
Serveur --> C1 : true
C1 -> Serveur: allPlayers()
Serveur --> C1: {}


C2 -> Serveur: Connect("Romain")
Serveur --> C2 : true
C2 -> Serveur : allPlayers()
Serveur --> C2 : {"Teddy": false}

Serveur --> C1 : newPlayer("Romain")


C3 -> Serveur: Connect("Romain")
Serveur --> C3 : true
Serveur --> C3 : changePseudo("Romain0")
C3 --> Serveur : allPlayers()
Serveur --> C3 : {"Teddy": false, "Romain": false}

Serveur --> C1 : newPlayer("Romain0")
Serveur --> C2 : newPlayer("Romain0")

C1 -> Serveur: ready("Teddy")
Serveur -> C2 : playerReady("Teddy")
Serveur -> C3 : playerReady("Teddy")

C2 -> Serveur: ready("Romain")
Serveur -> C1 : playerReady("Romain")
Serveur -> C3 : playerReady("Romain")

C3 -> Serveur: ready("Romain0")
Serveur -> C1 : playerReady("Romain0")
Serveur -> C2 : playerReady("Romain0")


Serveur -> C1 : play()
Serveur -> C2 : play()
Serveur -> C3 : play()

@enduml
....

.Déroulement de l'initialisation du tour 1
[plantuml]
....
@startuml

actor "ClientA:Client" as C1
actor "ClientB:Client" as C2
actor "ClientC:Client" as C3


@enduml
....

.Déroulement d'un tour (on suppose les clients déjà initialisés et le tour 4)

[plantuml]
....
@startuml

actor "Rom:Client" as C1
actor "Ted:Client" as C2
actor "Isma:Client" as C3


@enduml
....

.Rejoindre une partie
[plantuml]
....
participant "__one:Player__" as player1
participant "__two:Player__" as player2
participant "__three:Player__" as player3
participant "__four:Player__" as player4
participant "__five:Player__" as player5
participant "__six:Player__" as player6
participant "__game:GameServer__" as game

player1 -> game : id := createGame(6)
par
    player1 ->> game : playerId := join(id, one)
    player2 ->> game : playerId := join(id, two)
    player3 ->> game : playerId := join(id, three)
    player4 ->> game : playerId := join(id, four)
    player5 ->> game : playerId := join(id, five)
    player6 ->> game : playerId := join(id, six)
end
    game    --> player1: notifyPlayersReady()
    player1 -> game: role := chooseRole("Creature", two)
par
    game    --> player1: gameStart(boardGameState)
    game    --> player2: gameStart(boardGameState)
    game    --> player3: gameStart(boardGameState)
    game    --> player4: gameStart(boardGameState)
    game    --> player5: gameStart(boardGameState)
    game    --> player6: gameStart(boardGameState)
end
....