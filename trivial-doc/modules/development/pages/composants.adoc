 = Spécification des composants

[NOTE]
====
Objectif::
Découpage de la solution en composants (ou sous-systèmes), affectation des responsabilités aux composants et spécification des interfaces fournies et requises par ces composants

Moyens::
Utilisez des diagrammes d'interaction (séquence, communication) pour décrire l'échange de messages entre les composants pour en déduire leurs interfaces.
====

== Vue globale des composants

.Diagramme de composants décrivant la solution proposée
[plantuml]
....
include::example$sober.config[]
include::example$dc-global.puml[]
....

.Un autre exemple

== Composant : Game server

[plantuml]
....
include::example$sober.config[]
@startuml
left to right direction

component A as "Game server" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required


sws --() Provided
Required  )-- cws
@enduml
....

=== Responsabilités du Composant A

* Serveur :

.Gestion de compte
* Ajouter des pseudos et creér un utilisateur.
* Recevoir les identifiants de connexion et authentifier un utilisateur.
* Modifier le mot de passe/détails de l'utilisateur.
* Créer un profil(Admin/joueur).

.Gestion des parties de jeu
* Créer une nouvelle partie.
* Renvoyer la liste des parties disponibles.
* Ajouter/retirer un jouer dans une partie.
* Sauvegarder la partie en cours.
* Renvoyer l'etat d'une partie.
* Renvoyer le nombre de joueur par partie.
* Mettre fin à une partie


.Gestion du jeu
* Retourner la liste des camembert disponibles.
* Attribuer un camembert à un joueur.
* Retourner la liste des cartes disponible.
* Donner le tour d'un joueur.
* Retourner une valeur de dé(Lancer le dé).
* Retourner la question d'une carte correspondant à la couleur et les propositions de réponses.
* Chronometrer la durée pour une réponse.
* Valider la réponse du joueur.
* Ajouter un triangle à un camembert.
* Definir le joeur gagnant.




=== Interfaces fournies

==== Interface Account

[TIP]
====
Utilisez la notation UML pour spécifier la signature de chaque operation de l'interface.

====

[WARNING]
====
* La syntaxe de la notation UML est différente de celle de Java{nbsp}!
* Les types de base sont  différents aussi{nbsp}! Par exemple, `int`, `float`, `bool` ne sont pas des types UML.
* Si les paramètres sont multivalués (par ex. ensemble, séquence, etc.) utilisez les cardinalités: `names : String [1..4]`
* `List<>`, `Set<>`, etc. ne sont pas des types UML.
====

[plantuml]
....
interface Account {
    Connect(String mail, String mot_de_passe): Boolean
    CreateAccount(String nom, String prenom, String email, String mot_de_passe) : Url
    ValideAccount() : Boolean
}
....

TIP: Si nécessaire, utilisez le langage OCL pour spécifier les pré et post-conditions des opérations.

.Contraintes sur les operations
[source, ocl]
----
context A::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----


==== Interface RejoindrePartie

[plantuml]
....
interface JoinGame {
    JoinPartie(String gameId, String playeId) : Boolean
    GetListPartieDisponible() : List<String>
    GetNombredeJoueur(String gameId) : Integer
    GetEtatPartie(String gameId) : String
    AddJoueurPartie(String gameId, String playeId) : Boolean
    RetirJoueurPartie(String gameId, String playeId playeId) : Boolean
    FinPartie(String gameId) : Boolean

}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----

[plantuml]
....
interface Play {
    TourJoueur(String gameId): String
    LenceDe(String gameId) : Integer
    RetournValeurDe(String gameId) : Integer
}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----

[plantuml]
....
interface Plateau {
    RetourneListeCamembert(String gameId, String playeId, Strign camembertType): Boolean
    CarteDisponible() : List<String>
    ChooseCarte(String gameId, String carteId) : Boolean
}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----

== Composant A

[note]
====
Description de ses responsabilités et de ses interfaces
====

=== Interface C
[plantuml]
....
interface GameServer {
connect(pseudo: String, password: String, ip: String, port: Integer):Boolean
createGame(numberOfPlayers : Integer): Integer
join(gameId : Integer): Integer
notifyPlayersReady(): String
chooseRole(role: String, playerId: Integer)
resist(numberOfPawns: Integer)
playPlaceCard(playerId: Integer, cardName: String)
playHuntCard(cardName: String)
letGo()
putToken(tokenName: String, cardNames: String [0..2])
}
....

== Composant : serveur Client

[plantuml]
....
include::example$sober.config[]
@startuml
left to right direction

component A as "Game Client" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required

sws --() Provided
Required  )-- cws
@enduml
....

=== Interfaces fournies

=== Responsabilités du Composant CLient


== Composant : serveur Data

[plantuml]
....
include::example$sober.config[]
@startuml
left to right direction

component A as "Game Data" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required

sws --() Provided
Required  )-- cws
@enduml
....

=== Interfaces fournies

=== Responsabilités du Composant Data

== Interactions

[TIP]
====
* Utilisez les diagrammes d'interaction de la notation UML pour valider les interfaces des composants.

* Basez-vous sur les cas d'utilisation (spécification des exigences) pour illustrer les interactions entre les différents composants
====

[WARNING]
====
* En UML, les interactions se passent au niveau des instances.
* Rappel:
** Niveau classes: Classes, opérations, types, etc.
** Niveau instances: Objets, appels d'opération, valeurs, etc.
====

.Connexion au serveur
[plantuml]
....
@startuml

actor "ClientA:Client" as C1
actor "ClientB:Client" as C2
actor "ClientC:Client" as C3

C1 -> Serveur: Connect("Teddy")
Serveur --> C1 : true
C1 -> Serveur: allPlayers()
Serveur --> C1: {}


C2 -> Serveur: Connect("Romain")
Serveur --> C2 : true
C2 -> Serveur : allPlayers()
Serveur --> C2 : {"Teddy": false}

Serveur --> C1 : newPlayer("Romain")


C3 -> Serveur: Connect("Romain")
Serveur --> C3 : true
Serveur --> C3 : changePseudo("Romain0")
C3 --> Serveur : allPlayers()
Serveur --> C3 : {"Teddy": false, "Romain": false}

Serveur --> C1 : newPlayer("Romain0")
Serveur --> C2 : newPlayer("Romain0")

C1 -> Serveur: ready("Teddy")
Serveur -> C2 : playerReady("Teddy")
Serveur -> C3 : playerReady("Teddy")

C2 -> Serveur: ready("Romain")
Serveur -> C1 : playerReady("Romain")
Serveur -> C3 : playerReady("Romain")

C3 -> Serveur: ready("Romain0")
Serveur -> C1 : playerReady("Romain0")
Serveur -> C2 : playerReady("Romain0")


Serveur -> C1 : play()
Serveur -> C2 : play()
Serveur -> C3 : play()

@enduml
....

.Déroulement de l'initialisation du tour 1
[plantuml]
....
@startuml

actor "ClientA:Client" as C1
actor "ClientB:Client" as C2
actor "ClientC:Client" as C3


@enduml
....

.Déroulement d'un tour (on suppose les clients déjà initialisés et le tour 4)

[plantuml]
....
@startuml

actor "Rom:Client" as C1
actor "Ted:Client" as C2
actor "Isma:Client" as C3


@enduml
....

.Rejoindre une partie
[plantuml]
....
participant "__one:Player__" as player1
participant "__two:Player__" as player2
participant "__three:Player__" as player3
participant "__four:Player__" as player4
participant "__five:Player__" as player5
participant "__six:Player__" as player6
participant "__game:GameServer__" as game

player1 -> game : id := createGame(6)
par
    player1 ->> game : playerId := join(id, one)
    player2 ->> game : playerId := join(id, two)
    player3 ->> game : playerId := join(id, three)
    player4 ->> game : playerId := join(id, four)
    player5 ->> game : playerId := join(id, five)
    player6 ->> game : playerId := join(id, six)
end
    game    --> player1: notifyPlayersReady()
    player1 -> game: role := chooseRole("Creature", two)
par
    game    --> player1: gameStart(boardGameState)
    game    --> player2: gameStart(boardGameState)
    game    --> player3: gameStart(boardGameState)
    game    --> player4: gameStart(boardGameState)
    game    --> player5: gameStart(boardGameState)
    game    --> player6: gameStart(boardGameState)
end
....