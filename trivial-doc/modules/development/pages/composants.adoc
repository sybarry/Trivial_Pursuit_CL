 = Spécification des composants

[NOTE]
====
Objectif::
Découpage de la solution en composants (ou sous-systèmes), affectation des responsabilités aux composants et spécification des interfaces fournies et requises par ces composants

Moyens::
Utilisez des diagrammes d'interaction (séquence, communication) pour décrire l'échange de messages entre les composants pour en déduire leurs interfaces.
====

== Vue globale des composants

.Diagramme de composants décrivant la solution proposée
[plantuml]
....
include::example$sober.config[]
include::example$dc-global.puml[]
....

.Un autre exemple

== Composant A : Game server

[plantuml]
....
include::example$sober.config[]
@startuml
left to right direction

component A as "Game server" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required


sws --() Provided
Required  )-- cws
@enduml
....

=== Responsabilités du Composant A

* Serveur :

.Gestion de compte
* Ajouter des pseudos et creér un utilisateur.
* Recevoir les identifiants de connexion et authentifier un utilisateur.
* Modifier le mot de passe/détails de l'utilisateur.
* Créer un profil(Admin/joueur).

.Gestion des parties de jeu
* Créer une nouvelle partie.
* Renvoyer la liste des parties disponibles.
* Ajouter/retirer un jouer dans une partie.
* Sauvegarder la partie en cours.
* Renvoyer l'etat d'une partie.
* Renvoyer le nombre de joueur par partie.
* Mettre fin à une partie


.Gestion du jeu
* Retourner la liste des camembert disponibles.
* Attribuer un camembert à un joueur.
* Retourner la liste des cartes disponible.
* Donner le tour d'un joueur.
* Retourner une valeur de dé(Lancer le dé).
* Retourner la question d'une carte correspondant à la couleur et les propositions de réponses.
* Chronometrer la durée pour une réponse.
* Valider la réponse du joueur.
* Ajouter un triangle à un camembert.
* Definir le joeur gagnant.


=== Interfaces fournies

==== Interface Account

[TIP]
====
Utilisez la notation UML pour spécifier la signature de chaque operation de l'interface.

====

[WARNING]
====
* La syntaxe de la notation UML est différente de celle de Java{nbsp}!
* Les types de base sont  différents aussi{nbsp}! Par exemple, `int`, `float`, `bool` ne sont pas des types UML.
* Si les paramètres sont multivalués (par ex. ensemble, séquence, etc.) utilisez les cardinalités: `names : String [1..4]`
* `List<>`, `Set<>`, etc. ne sont pas des types UML.
====

[plantuml]
....
interface Account {
    Connect(email: String, password :String): Boolean
    CreateAccount(String firstname, String lastname, String email, password: String) : String
    validateAccount() : Boolean
}
....

TIP: Si nécessaire, utilisez le langage OCL pour spécifier les pré et post-conditions des opérations.

.Contraintes sur les operations
[source, ocl]
----
context A::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----


==== Interface RejoindrePartie

[plantuml]
....
interface JoinGame {
    joinGamePart(gamePartId: String, userId: String) : Boolean
    getAvailableGameParts() : GameParts[]
    getNumberOfPlayers(gameId: String) : Integer
    getGamePart(String gamePartId) : String
    addPlayer(String gamePartId, userId: String) : Boolean
    removePlayer(gamePartId: String, userId: String) : Boolean
    endGamePart(gamePartId: String): String
}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----

[plantuml]
....
interface Play {
    getAvailableBoxes(diceValue: Integer, userId: String): Boxes[]
    isPlayerTurn(gamePartId: String, userId: String): Boolean
    diceRoll(String userId) : Integer
    chooseBox(boxName: String, userId: String) : String
    showQuestion(boxColor: String): String
    checkAnswer(answer: String): Boolean
    addTriangle(boxColor: String, userId: String): Boolean
}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----

[plantuml]
....
interface initialiseGame {
    createGamePart(gamePartName: String, userId: String, numberOfPlayers: Integer): gamePartId: String
    getCamembertList(gamePartId: String): Camemberts[]
    getAllCards() : Cards[]
    ChooseCamembert(camembertColor: String, userId: String) : Boolean
}
....

.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----

== Composant B: Client(User Interface)
[plantuml]
....
include::example$sober.config[]
@startuml
left to right direction

component A as "Game Client" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required

sws --() Provided
Required  )-- cws
@enduml
....
=== Responsabilités du Composant B
* Interface utilisateur :

.UI de connexion
* Afficher l'interface de connexion
* Entrer un pseudo/mail et un mot de passe
* Afficher l'interface pour la creation de compte
* Entrer un mail, un nom, un prenom, une date de naissance, un mot de passe
* Afficher l'interface pour la modification de compte
* entrer les informations a modifier

.UI du Jeu
* Selctionner mon niveau(Beginner, intermediate, advanced)
* Affichier la liste des parties disponibles
* Selectionner et integrer une partie

.UI du plateau de jeu
* Selectionner un camenbert
* Lancer un de
* Afficher la valeur de de
* Deplacer un camenbert
* Afficher une question et les propositions de reponses
* Repondre a une question
* Ajouter un triangle dans un camenbert
* Afficher le tour du prochain joueur
* Afficher le joueur gagnant
* Afficher la fin d'une partie


=== Interfaces fournies
[plantuml]
....
interface GameServer {
connect(pseudo: String, password: String, ip: String, port: Integer):Boolean
createGame(numberOfPlayers : Integer): Integer
join(gameId : Integer): Integer
notifyPlayersReady(): String
chooseRole(role: String, playerId: Integer)
resist(numberOfPawns: Integer)
playPlaceCard(playerId: Integer, cardName: String)
playHuntCard(cardName: String)
letGo()
putToken(tokenName: String, cardNames: String [0..2])
}
....


== Composant : Game Data

[plantuml]
....
include::example$sober.config[]
@startuml
left to right direction

component A as "Game Data" {
    portin "WebSockets" as cws
    portout "HTTP" as sws
}

interface Provided

interface Required

sws --() Provided
Required  )-- cws
@enduml
....


=== Responsabilités du Composant  Game data
* Base de donnees :

.Stockage des donnees

* Stocker les utilisateurs
* Stocker les parties de jeu
* Stocker les cartes
* Stocker les cases
* Stocker les camenberts
* Stocker les triangles


=== Interfaces fournies

[plantuml]
....
interface AddData {
addUser(): String
addGamePart() : String
}
....
.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----
[plantuml]
....
interface GetData {
getUser(userId: String): User
getGamePart(): GameParts[]
getCards(): Cards[]
getBoxes() : Boxes[]
getCamemberts(): Camemberts[]
}
....
.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----
[plantuml]
....
interface UpdateData {
updateUser(userId: String, data: String):userId: String
updateGamePart(gamePartId: String): Boolean
updateBoxes(boxName: String, userId: String): Boolean
updateCamembert(camembertColor: String): Boolean
}
....
.Contraintes sur les operations
[source, ocl]
----
context B::operationA(a: String, b: Integer): Boolean
pre: a.size() > 3
post:
-- Pas de postconditions
----
== Interactions

[TIP]
====
* Utilisez les diagrammes d'interaction de la notation UML pour valider les interfaces des composants.

* Basez-vous sur les cas d'utilisation (spécification des exigences) pour illustrer les interactions entre les différents composants
====

[WARNING]
====
* En UML, les interactions se passent au niveau des instances.
* Rappel:
** Niveau classes: Classes, opérations, types, etc.
** Niveau instances: Objets, appels d'opération, valeurs, etc.
====

.Connexion au serveur
[plantuml]
....
@startuml

actor "ClientA:Client" as C1
actor "ClientB:Client" as C2
actor "ClientC:Client" as C3

C1 -> Serveur: Connect("Teddy")
Serveur --> C1 : true
C1 -> Serveur: allPlayers()
Serveur --> C1: {}


C2 -> Serveur: Connect("Romain")
Serveur --> C2 : true
C2 -> Serveur : allPlayers()
Serveur --> C2 : {"Teddy": false}

Serveur --> C1 : newPlayer("Romain")


C3 -> Serveur: Connect("Romain")
Serveur --> C3 : true
Serveur --> C3 : changePseudo("Romain0")
C3 --> Serveur : allPlayers()
Serveur --> C3 : {"Teddy": false, "Romain": false}

Serveur --> C1 : newPlayer("Romain0")
Serveur --> C2 : newPlayer("Romain0")

C1 -> Serveur: ready("Teddy")
Serveur -> C2 : playerReady("Teddy")
Serveur -> C3 : playerReady("Teddy")

C2 -> Serveur: ready("Romain")
Serveur -> C1 : playerReady("Romain")
Serveur -> C3 : playerReady("Romain")

C3 -> Serveur: ready("Romain0")
Serveur -> C1 : playerReady("Romain0")
Serveur -> C2 : playerReady("Romain0")


Serveur -> C1 : play()
Serveur -> C2 : play()
Serveur -> C3 : play()

@enduml
....

.Déroulement de l'initialisation du tour 1
[plantuml]
....
@startuml

actor "ClientA:Client" as C1
actor "ClientB:Client" as C2
actor "ClientC:Client" as C3


@enduml
....

.Déroulement d'un tour (on suppose les clients déjà initialisés et le tour 4)

[plantuml]
....
@startuml

actor "Rom:Client" as C1
actor "Ted:Client" as C2
actor "Isma:Client" as C3


@enduml
....

.Rejoindre une partie
[plantuml]
....
participant "__one:Player__" as player1
participant "__two:Player__" as player2
participant "__three:Player__" as player3
participant "__four:Player__" as player4
participant "__five:Player__" as player5
participant "__six:Player__" as player6
participant "__game:GameServer__" as game

player1 -> game : id := createGame(6)
par
    player1 ->> game : playerId := join(id, one)
    player2 ->> game : playerId := join(id, two)
    player3 ->> game : playerId := join(id, three)
    player4 ->> game : playerId := join(id, four)
    player5 ->> game : playerId := join(id, five)
    player6 ->> game : playerId := join(id, six)
end
    game    --> player1: notifyPlayersReady()
    player1 -> game: role := chooseRole("Creature", two)
par
    game    --> player1: gameStart(boardGameState)
    game    --> player2: gameStart(boardGameState)
    game    --> player3: gameStart(boardGameState)
    game    --> player4: gameStart(boardGameState)
    game    --> player5: gameStart(boardGameState)
    game    --> player6: gameStart(boardGameState)
end
....